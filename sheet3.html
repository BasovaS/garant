<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ì–µ–º–æ—Ç–µ—Å—Ç</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div id="header-placeholder"></div>
  <script src="main.js" defer></script>

  <main>
    <div class="app">
      <div class="sidebar">
        <div class="result-header">–ò—Ç–æ–≥</div>
        <pre id="resultText" class="result-box"></pre>
        <div class="buttons">
          <button id="generateBtn">–°–æ–∑–¥–∞—Ç—å –ì–ü</button>
          <button id="resetBtn">–°–±—Ä–æ—Å–∏—Ç—å</button>
          <button id="copyBtn">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
        <div id="toast" class="toast">–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</div>
      </div>

      <div class="table-section">
        <div class="search-bar">
          <input type="text" id="searchInput" placeholder="–ü–æ–∏—Å–∫ –ø–æ —Ç–∞–±–ª–∏—Ü–µ...">
        </div>
        <div id="tableContainer"></div>
      </div>
    </div>
  </main>



  <script>
async function loadExcel() {
  try {
    const response = await fetch('analyses.xlsx');
    if (!response.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª');
    
    const arrayBuffer = await response.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: "array" });
    
    // –ü–æ–ª—É—á–∞–µ–º –õ–∏—Å—Ç 1
    const sheet = workbook.Sheets[workbook.SheetNames[2]]; // –õ–∏—Å—Ç 1 –±—É–¥–µ—Ç –ø–µ—Ä–≤—ã–º –≤ –º–∞—Å—Å–∏–≤–µ
    renderTableFromSheet(sheet);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ Excel —Ñ–∞–π–ª–∞:', error);
  }
}

function renderTableFromSheet(sheet) {
  const table = document.createElement('table');
  table.id = 'dataTable';
  const range = XLSX.utils.decode_range(sheet['!ref']);
  const merges = sheet['!merges'] || [];
  const occupied = {};

  // –†–µ–Ω–¥–µ—Ä–∏–º —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
  for (let R = range.s.r; R <= range.e.r; ++R) {
    const row = document.createElement('tr'); 

    for (let C = range.s.c; C <= range.e.c; ++C) {
      if (occupied[`${R},${C}`]) continue; // –ï—Å–ª–∏ —è—á–µ–π–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—ë

      const cellRef = XLSX.utils.encode_cell({ c: C, r: R });
      const cell = sheet[cellRef];
      const td = document.createElement(R === 0 ? 'th' : 'td');

      // –ï—Å–ª–∏ —è—á–µ–π–∫–∞ –ø—É—Å—Ç–∞, —Å—Ç–∞–≤–∏–º —Ç–µ–∫—Å—Ç –≤ –≤–∏–¥–µ –ø—Ä–æ–±–µ–ª–∞
      const cellText = cell ? cell.v : '';

      // –ß–µ–∫–±–æ–∫—Å—ã –≤ –ø–µ—Ä–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ (–ê), –∫—Ä–æ–º–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞
      if (C === 0 && R !== 0) {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        td.appendChild(checkbox);
      } else {
        td.textContent = cellText || ' '; // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø—É—Å—Ç—ã–µ —è—á–µ–π–∫–∏ –ø—Ä–æ–±–µ–ª–æ–º
      }

      const merge = merges.find(m =>
        R >= m.s.r && R <= m.e.r &&
        C >= m.s.c && C <= m.e.c
      );

      if (merge) {
        const rowspan = merge.e.r - merge.s.r + 1;
        const colspan = merge.e.c - merge.s.c + 1;
        if (rowspan > 1) td.rowSpan = rowspan;
        if (colspan > 1) td.colSpan = colspan;
        td.classList.add('merged-cell');

        // –û—Ç–º–µ—Ç–∏–º —è—á–µ–π–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –∑–∞–Ω—è—Ç—ã –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ–º
        for (let r = merge.s.r; r <= merge.e.r; r++) {
          for (let c = merge.s.c; c <= merge.e.c; c++) {
            if (r === R && c === C) continue;
            occupied[`${r},${c}`] = true;
          }
        }
      }

      row.appendChild(td);
    }

    table.appendChild(row);
  }

  // –î–æ–±–∞–≤–∏–º —Ç–∞–±–ª–∏—Ü—É –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
  const container = document.getElementById('tableContainer');
  if (container) {
    container.innerHTML = ''; // –û—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–µ—Ä–µ–¥ —Ä–µ–Ω–¥–µ—Ä–æ–º
    container.appendChild(table);
  } else {
    console.error('–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –Ω–µ –Ω–∞–π–¥–µ–Ω!');
  }
}

document.getElementById('generateBtn').addEventListener('click', () => {
  const table = document.getElementById('dataTable');
  if (!table) return;

  const rows = table.getElementsByTagName('tr');
  let selectedTests = [];
  let resultText = 'ID 10524 –û–û–û ¬´–ë–µ—Å—Ç–¥–æ–∫—Ç–æ—Ä¬ª\n';  // –°—Ç–∞—Ä—Ç–æ–≤—ã–π —Ç–µ–∫—Å—Ç

  for (let i = 1; i < rows.length; i++) {
    const row = rows[i];
    const checkbox = row.cells[0]?.querySelector('input[type="checkbox"]');
    if (checkbox && checkbox.checked) {
      const testNumber = row.cells[1]?.textContent.trim() || '';
      const testText = row.cells[2]?.textContent.trim() || '';

      selectedTests.push(`${testNumber} - ${testText} - 1 —à—Ç.`);
    }
  }

  resultText += selectedTests.join("\n");

  if (selectedTests.length > 0) {
    resultText += "\n–ê–¥—Ä–µ—Å: ";
  } else {
    resultText = "–ù–µ –≤—ã–±—Ä–∞–Ω—ã –∞–Ω–∞–ª–∏–∑—ã.";
  }

  document.getElementById('resultText').textContent = resultText;
});

document.getElementById('resetBtn').addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('input[type="checkbox"]');
  checkboxes.forEach(checkbox => checkbox.checked = false);
  document.getElementById('resultText').textContent = '';
});

document.getElementById('copyBtn').addEventListener('click', () => {
  const resultText = document.getElementById('resultText').textContent;
  navigator.clipboard.writeText(resultText)
    .then(() => {
      const toast = document.getElementById('toast');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    });
});

// –ü–æ–∏—Å–∫ –ø–æ —Ç–∞–±–ª–∏—Ü–µ
const searchInput = document.getElementById("searchInput");
searchInput.addEventListener("input", () => {
  const filter = searchInput.value.toLowerCase();
  const rows = document.querySelectorAll("#dataTable tr");

  rows.forEach((row, index) => {
    if (index === 0) return;
    const cells = Array.from(row.cells).map((cell) => cell.textContent.toLowerCase());
    const isMatch = cells.some((text) => text.includes(filter));
    row.style.display = isMatch ? "" : "none";
  });
});

loadExcel();

  </script>
</body>
</html>
